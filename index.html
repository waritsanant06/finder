<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>finder</title>

  <!-- Start splash timing ASAP (before CSS/DOM finishes) -->
  <script>
    window.__splashStart = performance.now();
  </script>

  <!-- Preload & prioritize the logo so it paints fast -->
  <link rel="preload" as="image" href="./logo.svg" imagesrcset="./logo.svg" />

  <style>
    :root{
      --bg:#0b1220;/* deep sea */
      --card:#111a2b;
      --accent:#27d3ff;
      --ok:#20c997;
      --bad:#ff4d6d;
      --text:#e6f1ff;
      --muted:#99a8bf;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:linear-gradient(180deg,#06101d 0%, #0b1220 60%, #0f1a2e 100%);
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      display:flex; flex-direction:column; align-items:center; gap:16px;
    }

    /* Loading Screen (CSS counterpart to the inline style for first paint) */
    #loading {
      transition: opacity .45s ease;
    }
    #loading.fade-out {
      opacity:0;
      pointer-events:none;
    }
    #loading img {
      width:180px;
      height:auto;
      animation:pulse 1.2s ease-in-out infinite alternate;
    }
    @keyframes pulse {
      from { transform:scale(1); opacity:0.92; }
      to   { transform:scale(1.08); opacity:1; }
    }

    header{
      width:100%; max-width:900px; padding:16px 20px; display:flex; flex-wrap:wrap; align-items:center; justify-content:space-between;
    }
    .hud{display:flex; gap:10px; align-items:center}
    .hud .chip{background:#101a2c; border:1px solid #22314a; padding:6px 12px; border-radius:12px; font-weight:600}
    .chip .lab{color:var(--muted); font-weight:500; margin-right:6px}

    main{width:100%; max-width:900px; padding:0 20px 24px; display:grid; gap:14px}
    .prompt{text-align:center; font-size:clamp(18px,4vw,24px); font-weight:700; letter-spacing:0.2px;}
    .prompt .name{color:var(--accent)}
    .stage{position:relative; height:min(72vh,640px); min-height:420px; width:100%; display:grid; place-items:center;}
    .stack{position:relative; width:min(88vw,560px); height:min(68vh,560px);}
    .card{ position:absolute; inset:0; background:var(--card); border-radius:22px; overflow:hidden;
      box-shadow:0 10px 30px rgba(0,0,0,.35), 0 0 0 1px rgba(255,255,255,.05);
      display:grid; grid-template-rows:1fr; user-select:none; touch-action:none;
      transform-origin:50% 85%; will-change:transform,opacity; transition:box-shadow .2s ease;
      -webkit-user-drag:none; -webkit-touch-callout:none;
    }
    .card:not(.top){ transform:translateY(calc(var(--i,0)*-3px)) scale(calc(1 - var(--i,0)*0.01)); filter:brightness(calc(1 - var(--i,0)*0.03)); }
    .card.top{ cursor:grab; }
    .card:active.top{ cursor:grabbing; }
    .photo{ position:relative; overflow:hidden;}
    .photo img{ width:100%; height:100%; object-fit:cover; display:block; pointer-events:none; -webkit-user-drag:none; }
    .label{ position:absolute; top:12px; left:12px; right:12px; display:flex; justify-content:space-between; pointer-events:none;}
    .flag{ font-weight:800; font-size:22px; letter-spacing:.5px; padding:8px 12px; border-radius:12px; border:3px solid transparent; transform:rotate(-8deg); opacity:0; }
    .flag.right{ color:#0f5132; background:rgba(32,201,151,.9); border-color:#59e1bd; }
    .flag.left{ color:#842029; background:rgba(255,90,102,.92); border-color:#ffb2ba; transform:rotate(8deg); }
    .card.show-like .flag.right{opacity:1}
    .card.show-nope .flag.left{opacity:1}

    .controls{ display:flex; justify-content:center; gap:16px; }
    .btn {
      display:flex; align-items:center; justify-content:center;
      width:70px; height:70px; border-radius:50%;
      border:none; font-weight:900; font-size:36px; cursor:pointer;
      transition:transform 0.15s ease; box-shadow:0 4px 18px rgba(0,0,0,.35);
    }
    .btn.bad{ background:#ff4d6d; color:white; }
    .btn.good{ background:#20c997; color:white; }
    .btn:hover{ transform:scale(1.05); }
    .btn:active{ transform:scale(0.96); }

    .feedback{ position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); font-size:72px; font-weight:900; pointer-events:none; opacity:0; z-index:50; text-shadow:0 4px 20px rgba(0,0,0,.5); transition:opacity .15s ease;}
    .feedback.show{ opacity:1 }
    .feedback.correct{ color:#20c997 }
    .feedback.wrong{ color:#ff4d6d }

    .over{ position:fixed; inset:0; display:none; place-items:center; background:rgba(3,8,20,.85); backdrop-filter:blur(3px); z-index:200; animation:fadeIn .3s ease}
    @keyframes fadeIn{ from{opacity:0} to{opacity:1} }
    .panel{ background:#0d1728; border:1px solid #294063; padding:28px; border-radius:18px; width:min(440px,90vw); text-align:center; box-shadow:0 12px 40px rgba(0,0,0,.45); animation:slideUp .3s ease;}
    @keyframes slideUp{ from{transform:translateY(20px);opacity:0} to{transform:translateY(0);opacity:1} }
    .panel h2{ margin:0 0 12px 0; font-size:28px; color:var(--accent) }
    .panel p{ margin:0 0 16px 0; color:var(--muted); line-height:1.5}
    .panel .score-big{ font-size:48px; font-weight:900; color:var(--ok); margin:8px 0 16px }
    .panel .tip{ background:#0a1422; border:1px solid #1e3050; padding:12px; border-radius:10px; margin:16px 0; font-size:13px}

    .howto { position: fixed; inset: 0; display: none; place-items: center; background: rgba(3,8,20,.85); backdrop-filter: blur(3px); z-index: 300; animation: fadeIn .25s ease; }
    .howto .panel { position: relative; width: min(520px, 92vw); background: #0d1728; border: 1px solid #294063; border-radius: 18px; padding: 22px 22px 18px; text-align: left; box-shadow: 0 12px 40px rgba(0,0,0,.45); animation: slideUp .25s ease; }
    .howto h2 { margin: 0 0 10px 0; color: var(--accent); }
    .howto p { margin: 0 0 10px 0; color: var(--muted); line-height: 1.55; }
    .howto .list { margin: 10px 0 0 0; padding-left: 18px; }
    .howto .close { position: absolute; top: 10px; right: 12px; font-weight: 900; border: none; background: transparent; color: #cbd6ee; font-size: 22px; cursor: pointer; }
  </style>
</head>
<body>

  <!-- SPLASH FIRST: inline styles so it paints before CSS finishes -->
  <div id="loading"
       style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#0b1220;z-index:2147483647;">
    <img id="loadingLogo"
         src="./logo.svg"
         alt="Marine Match Logo"
         width="180"
         height="180"
         decoding="sync"
         fetchpriority="high"
         style="display:block;width:180px;height:auto;" />
  </div>

  <!-- Header -->
  <header style="position:fixed; top:16px; left:50%; transform:translateX(-50%); z-index:10; display:flex; align-items:center; gap:16px;">
    <img src="./logo.svg" alt="Finder Logo" style="width:90px; height:auto;">
    <div class="hud" style="display:flex; align-items:center; gap:10px;">
      <div class="chip"><span class="lab">Score</span><span id="hudScore">0</span></div>
    </div>
  </header>

  <main style="margin-top:100px;">
    <div class="prompt">Find: <span class="name" id="targetName">‚Äì</span></div>

    <section class="stage">
      <div class="stack" id="stack"></div>
    </section>

    <div class="controls">
      <button class="btn bad" id="btnLeft">‚úó</button>
      <button class="btn good" id="btnRight">‚úì</button>
    </div>

    <!-- How to Play modal -->
    <div class="howto" id="howto">
      <div class="panel" role="dialog" aria-modal="true" aria-labelledby="howto-title">
        <button class="close" id="howtoClose" aria-label="Close">‚úï</button>
        <h2 id="howto-title">üéÆ How to Play</h2>
        <p>Swipe <b>RIGHT</b> when the photo matches the target creature name.</p>
        <p>Swipe <b>LEFT</b> for all others. The game ends on the first mistake.</p>
        <ul class="list">
          <li>Use arrow keys ‚¨ÖÔ∏è ‚û°Ô∏è or drag on touch screens.</li>
          <li>Score increases only on correct right swipes.</li>
          <li>The deck quietly refills when it gets low.</li>
        </ul>
      </div>
    </div>

    <div class="feedback" id="feedback"></div>

    <div class="over" id="overlay">
      <div class="panel">
        <h2>üåä Game Over!</h2>
        <div class="score-big" id="finalScore">0</div>
        <p>You correctly matched <b id="finalRounds">0</b> creatures!</p>
        <div class="tip">
          <div style="margin-bottom:6px">üí° <b>Remember:</b></div>
          <div>‚úì Swipe <span class="kbd">‚Üí</span> only when photo matches the target name</div>
          <div>‚úì Swipe <span class="kbd">‚Üê</span> for all other creatures</div>
          <div>‚úì Use keyboard arrows or click buttons</div>
        </div>
        <button class="btn" id="btnRestart" style="width:100%; margin-top:8px">üîÑ Play Again</button>
      </div>
    </div>
  </main>

  <script>
  /* =======================
     Splash: fixed duration from earliest start
     ======================= */
  (function() {
    const SHOW_MS = 2000;    // <- show the logo this long (tweakable)
    const FADE_MS = 450;

    function hideSplash() {
      const loading = document.getElementById('loading');
      if (!loading) return;
      loading.classList.add('fade-out');
      setTimeout(() => loading.remove(), FADE_MS + 50);
    }

    // Hide after SHOW_MS since head-start, regardless of image load events
    const elapsed = performance.now() - (window.__splashStart || 0);
    const wait = Math.max(0, SHOW_MS - elapsed);
    setTimeout(hideSplash, wait);
  })();

  /* =======================
     Game Code
     ======================= */
  const MIN_DECK_SIZE = 3;
  const MAX_ADD_EACH = 5;

  const creatures = [
    { name: 'Clownfish',         img: './clownfish.jpg' },
    { name: 'Blue Tang',         img: './bluetang.jpg' },
    { name: 'Manta Ray',         img: './manta.jpg' },
    { name: 'Green Sea Turtle',  img: './turtle.jpg' },
    { name: 'Dolphin',           img: './dolphin.jpg' },
    { name: 'Great White Shark', img: './shark.jpg' },
  ];

  const rand = (n) => Math.floor(Math.random()*n);
  function shuffleInPlace(arr){
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  let score = 0, round = 1;
  let targetIdx = 0;
  let deckIdxs = [];
  let stackEl, targetEl, hudScoreEl;
  let overlayEl, finalScoreEl, finalRoundsEl;
  let feedbackEl;
  let howtoEl, howtoCloseEl;

  // Initialize as soon as DOM is ready (don‚Äôt wait for images)
  document.addEventListener('DOMContentLoaded', () => {
    stackEl = document.getElementById('stack');
    targetEl = document.getElementById('targetName');
    hudScoreEl = document.getElementById('hudScore');
    overlayEl = document.getElementById('overlay');
    finalScoreEl = document.getElementById('finalScore');
    finalRoundsEl = document.getElementById('finalRounds');
    feedbackEl = document.getElementById('feedback');
    howtoEl = document.getElementById('howto');
    howtoCloseEl = document.getElementById('howtoClose');

    document.getElementById('btnLeft').addEventListener('click', () => programmaticSwipe(-1));
    document.getElementById('btnRight').addEventListener('click', () => programmaticSwipe(1));
    document.getElementById('btnRestart').addEventListener('click', restart);

    document.addEventListener('keydown', (e)=>{
      if (howtoEl.style.display === 'grid' && (e.key === 'Escape' || e.key === 'Esc')) hideHowto();
      if (overlayEl.style.display === 'grid') return;
      if (howtoEl.style.display === 'grid') return;
      if (e.key === 'ArrowLeft') programmaticSwipe(-1);
      if (e.key === 'ArrowRight') programmaticSwipe(1);
    });

    howtoCloseEl.addEventListener('click', hideHowto);
    howtoEl.addEventListener('click', (e) => { if (e.target === howtoEl) hideHowto(); });

    showHowto();   // show How-to on first load
    start();
  });

  function showHowto(){ howtoEl.style.display='grid'; }
  function hideHowto(){ howtoEl.style.display='none'; }

  function start(){
    score = 0; round = 1;
    buildInitialDeck();
    targetIdx = deckIdxs[rand(deckIdxs.length)];
    updateHud();
    renderDeck();
  }

  function restart(){ overlayEl.style.display='none'; start(); }

  function updateHud(){
    hudScoreEl.textContent = score;
    targetEl.textContent    = creatures[targetIdx]?.name || '‚Äî';
  }

  function buildInitialDeck(){
    deckIdxs = creatures.map((_, i) => i);
    shuffleInPlace(deckIdxs);
  }

  function replenishDeck(minSize = MIN_DECK_SIZE, maxAdd = MAX_ADD_EACH){
    let added = 0;
    if (deckIdxs.length >= creatures.length) return false;
    while (deckIdxs.length < minSize && added < maxAdd) {
      const candidate = rand(creatures.length);
      if (!deckIdxs.includes(candidate)) {
        deckIdxs.unshift(candidate);
        added++;
      } else {
        if (deckIdxs.length >= creatures.length - 1) break;
      }
    }
    return added > 0;
  }

  function renderDeck(){
    stackEl.innerHTML = '';
    deckIdxs.forEach((idx, position) => {
      const card = document.createElement('div');
      card.className = 'card';
      card.style.setProperty('--i', (deckIdxs.length-1-position));

      const photo = document.createElement('div');
      photo.className='photo';

      const img = document.createElement('img');
      img.loading = 'lazy'; // avoid blocking paint
      img.alt = creatures[idx].name;
      img.src = creatures[idx].img;

      const label = document.createElement('div');
      label.className = 'label';
      const like = document.createElement('div'); like.className='flag right'; like.textContent='MATCH';
      const nope = document.createElement('div'); nope.className='flag left'; nope.textContent='NOPE';
      label.append(like, nope);

      photo.append(img,label);
      card.append(photo);
      card.dataset.name = creatures[idx].name;
      stackEl.appendChild(card);
    });
    setTopCard();
  }

  function setTopCard(){
    const cards = [...stackEl.querySelectorAll('.card')];
    cards.forEach(c => c.classList.remove('top'));
    const top = cards.at(-1);
    if(!top) return;
    top.classList.add('top');
    initDrag(top);
  }

  function initDrag(card){
    let startX = 0, startY = 0, curX = 0, curY = 0;
    let dragging = false;
    let activeId = null;

    const onPointerDown = (e) => {
      if (typeof howtoEl !== 'undefined' && howtoEl?.style.display === 'grid') return;
      if (typeof overlayEl !== 'undefined' && overlayEl?.style.display === 'grid') return;

      e.preventDefault();
      dragging = true;
      activeId = e.pointerId ?? 'mouse';
      if (card.setPointerCapture && e.pointerId !== undefined) {
        try { card.setPointerCapture(e.pointerId); } catch(_) {}
      }

      startX = e.clientX;
      startY = e.clientY;
      curX = 0; curY = 0;
      card.style.transition = 'none';

      card.addEventListener('pointermove', onPointerMove, {passive:false});
      card.addEventListener('pointerup', onPointerUp, {passive:false});
      card.addEventListener('pointercancel', onPointerUp, {passive:false});
    };

    const onPointerMove = (e) => {
      if (!dragging || (activeId !== (e.pointerId ?? 'mouse'))) return;

      curX = e.clientX - startX;
      curY = e.clientY - startY;

      const rot = curX * 0.06;
      const tiltY = Math.min(60, Math.max(-60, curY));
      card.style.transform = `translate(${curX}px, ${tiltY}px) rotate(${rot}deg)`;

      const like = curX > 30;
      const nope = curX < -30;
      card.classList.toggle('show-like', like);
      card.classList.toggle('show-nope', nope);
    };

    const endDrag = (commitDir = 0, e = null) => {
      dragging = false;

      if (commitDir === 0){
        card.style.transition = 'transform .25s ease-out';
        card.style.transform = '';
        card.classList.remove('show-like','show-nope');
      } else {
        commitSwipe(card, commitDir);
      }

      if (card.releasePointerCapture && e?.pointerId !== undefined) {
        try { card.releasePointerCapture(e.pointerId); } catch(_) {}
      }

      card.removeEventListener('pointermove', onPointerMove);
      card.removeEventListener('pointerup', onPointerUp);
      card.removeEventListener('pointercancel', onPointerUp);

      activeId = null;
    };

    const onPointerUp = (e) => {
      if (activeId !== (e.pointerId ?? 'mouse')) return;
      const threshold = 120;
      const dir = curX > threshold ? 1 : (curX < -threshold ? -1 : 0);
      endDrag(dir, e);
    };

    card.addEventListener('pointerdown', onPointerDown, {passive:false});
  }

  function programmaticSwipe(dir){
    if (howtoEl.style.display === 'grid' || overlayEl.style.display==='grid') return;
    const top = stackEl.querySelector('.card.top'); if(!top) return;
    commitSwipe(top, dir);
  }

  function commitSwipe(card, dir){
    const toX = dir>0 ? window.innerWidth : -window.innerWidth;
    card.style.transition='transform .25s ease-out, opacity .25s ease-out';
    card.style.transform=`translate(${toX}px,-20px) rotate(${dir*25}deg)`;
    card.style.opacity='0.6';
    setTimeout(()=>{ card.remove(); evaluateSwipe(card, dir); }, 220);
  }

  function evaluateSwipe(card, dir){
    const pickedName = card.dataset.name;
    const targetName = creatures[targetIdx].name;
    const isMatchCard = pickedName === targetName;

    const removeIdx = deckIdxs.findIndex(ci => creatures[ci].name === pickedName);
    if (removeIdx !== -1) deckIdxs.splice(removeIdx, 1);

    if(dir>0){ // right = claim match
      if(isMatchCard){
        showFeedback('‚úì', 'correct');
        score += 1; round += 1; updateHud();
        if (deckIdxs.length === 0){ buildInitialDeck(); }
        replenishDeck();
        targetIdx = deckIdxs[rand(deckIdxs.length)];
        updateHud(); renderDeck();
      } else {
        showFeedback('‚úó', 'wrong'); setTimeout(gameOver, 400);
      }
    } else { // left = reject
      if(isMatchCard){
        showFeedback('‚úó', 'wrong'); setTimeout(gameOver, 400);
      } else {
        showFeedback('‚úì', 'correct');
        if (deckIdxs.length === 0){
          buildInitialDeck();
          if (!deckIdxs.includes(targetIdx)) { targetIdx = deckIdxs[rand(deckIdxs.length)]; }
        }
        replenishDeck(); renderDeck(); updateHud();
      }
    }
  }

  function showFeedback(symbol, type){
    feedbackEl.textContent = symbol;
    feedbackEl.className = `feedback ${type} show`;
    setTimeout(()=> feedbackEl.classList.remove('show'), 500);
  }

  function gameOver(){
    finalScoreEl.textContent = score;
    finalRoundsEl.textContent = score;
    overlayEl.style.display = 'grid';
  }
  </script>
</body>
</html>
